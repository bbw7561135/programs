!
!
!
!     This routine initializes the seed for the lagged Fibonacci 
!     random number generator for each zone.  The seeds are in seeds.
!     It is based on RNSTR from  
!     Seminumerical Algorithms, 3rd edition (1997)  by D E Knuth.
!     J. Finke, 6 February 2006.
      SUBROUTINE seed_zone(SEED)
      IMPLICIT INTEGER (A-Z)
      include 'general.pa'
      include 'commonblock.f90'

      PARAMETER (KK=19937)
      PARAMETER (LL=7083)
      PARAMETER (MM=2**30)
      PARAMETER (TT=70)
      PARAMETER (KKK=KK+KK-1)
      DIMENSION X(KKK)

      integer j, k, i
!

!     Skip this if using the linearly congruent random number 
!     generator from Numerical Recipies (i.e., ran1).
      if(rand_switch.eq.2) return

      IF (SEED .LT. 0) THEN
         SSEED=MM-1-MOD(-1-SEED,MM)
      ELSE
         SSEED=MOD(SEED,MM)
      END IF
      SS=SSEED-MOD(SSEED,2)+2
      DO 1 J=1,KK
         X(J)=SS
         SS=SS+SS
         IF (SS .GE. MM) SS=SS-MM+2
 1    CONTINUE
      X(2)=X(2)+1
      SS=SSEED
      T=TT-1
 10   DO 12 J=KK,2,-1
         X(J+J-1)=X(J)
 12      X(J+J-2)=0
      DO 14 J=KKK,KK+1,-1
         X(J-(KK-LL))=X(J-(KK-LL))-X(J)
         IF (X(J-(KK-LL)) .LT. 0) X(J-(KK-LL))=X(J-(KK-LL))+MM
         X(J-KK)=X(J-KK)-X(J)
         IF (X(J-KK) .LT. 0) X(J-KK)=X(J-KK)+MM
 14   CONTINUE
      IF (MOD(SS,2) .EQ. 1) THEN
         DO 16 J=KK,1,-1
 16      X(J+1)=X(J)
         X(1)=X(KK+1)
         X(LL+1)=X(LL+1)-X(KK+1)
         IF (X(LL+1) .LT. 0) X(LL+1)=X(LL+1)+MM
       END IF
       IF (SS .NE. 0) THEN
          SS=SS/2
       ELSE
          T=T-1
       END IF
       IF (T .GT. 0) GO TO 10

      i = 0
      do 20 j=1,nz
         do 21 k=1,nr
            i = i + 1
            seeds(j,k) = x(i)
!            write(*,*) 'i=',i,' x=',x(i),' seeds=',seeds(j,k)
 21      continue
 20   continue
      do 22 j=1, nz
         i = i + 1
         zseeds(j) = x(i)
 22   continue
      do 23 k=1, nr
         x(i) = i+1
         rseeds(k) = x(i)
 23   continue
      SEED = seeds(1,1)  ! this is of no use
!      stop

!       DO 20 J=1,LL
! 20       RANX(J+KK-LL)=X(J)
!       DO 21 J=LL+1,KK
! 21       RANX(J-LL)=X(J)
!
      end
!
!
!
!     This routine creates an array of random numbers for a 
!     particular job (j and k).  Random numbers can then be drawn
!     from this array with fibran.  Random numbers are
!     generated by RNFARR, a lagged Fibonacci generator from
!     Seminumerical Algorithms by D E Knuth, 3rd edition (1997).
!     J. Finke, 6 February 2006
      subroutine initialize_rand(j,k)
      implicit none
      integer j, k
      include 'mpif.h'
      include 'general.pa'
      include 'commonblock.f90'
!
      double precision time1, time2
!

!
!     Skip this if using the linearly congruent random number 
!     generator from Numerical Recipies.
      if(rand_switch.eq.2) return
!
      call RNFSTR( seeds(j,k) )
      call RNFARR( randlist, randmax )
!      write(*,*) 'seeds=',seeds(j,k),' randlist=',randlist(1)
!      seeds(j,k) = randlist(1)
!      write(*,*) 'new seeds=',seeds(j,k)
      randcounter = 1
!
      return
      end
!
!
!
!
!     This routine creates an array of random numbers for a 
!     particular z surface (j).  Random numbers can then be drawn
!     from this array with fibran.  Random numbers are
!     generated by RNFARR, a lagged Fibonacci generator from
!     Seminumerical Algorithms by D E Knuth, 3rd edition (1997).
!     J. Finke, 4 June 2006
      subroutine initialize_zrand(j)
      implicit none
      integer j
      include 'mpif.h'
      include 'general.pa'
      include 'commonblock.f90'
!

      double precision time1, time2
!
!
!     Skip this if using the linearly congruent random number 
!     generator from Numerical Recipies.
      if(rand_switch.eq.2) return
!
      call RNFSTR( zseeds(j) )
      call RNFARR( randlist, randmax )
      randcounter = 1
!
      return
      end
!
!
!
!
!
!
!
!     This routine creates an array of random numbers for a 
!     particular z surface (j).  Random numbers can then be drawn
!     from this array with fibran.  Random numbers are
!     generated by RNFARR, a lagged Fibonacci generator from
!     Seminumerical Algorithms by D E Knuth, 3rd edition (1997).
!     J. Finke, 4 June 2006
      subroutine initialize_rrand(k)
      implicit none
      integer k
      include 'mpif.h'
      include 'general.pa'
      include 'commonblock.f90'
!

      double precision time1, time2
!
!     Skip this if using the linearly congruent random number 
!     generator from Numerical Recipies.
      if(rand_switch.eq.2) return
!
      call RNFSTR( rseeds(k) )
      call RNFARR( randlist, randmax )
      randcounter = 1
!
      return
      end
!
!
!
!     This function draws a random number from the array of random
!     numbers for a specific job (j and k).  Random numbers are
!     generated by RNFARR, a lagged Fibonacci generator from
!     Seminumerical Algorithms by D E Knuth, 3rd edition (1997).
!     J. Finke, 6 February 2006
      double precision function fibran()
      implicit none
      include 'general.pa'
      include 'commonblock.f90'
!
!
      double precision ran1
!
!
!     Calls the ran1, the random number generator from Numerical
!     Recipies, if the user desires.
      if(rand_switch.eq.2) then
         fibran = ran1(rseed)
         return
      endif

!     If we have run out of random numbers, generate more; otherwise
!     grab a random number and return it.
!
      if(randcounter.ge.randmax) then
         call RNFARR( randlist, randmax )
         randcounter = 1
      else
         randcounter = randcounter + 1
      endif
!
      fibran = randlist(randcounter)
      return
      end
!
!     RNFSTR and RNFARR are random number generators from
!     Seminumerical Algorithms by D E Knuth.  RNFARR generates N
!     random numbers in the array AA, and RNFSTR generates the seeds
!     used in RNFARR.
!     J. Finke 31 January 2006
      SUBROUTINE RNFARR(AA,N)
!       FORTRAN 77 version of "ranf_array"
!       from Seminumerical Algorithms by D E Knuth, 3rd edition (1997)
!       including the MODIFICATIONS made in the 9th printing (2002)
!       ********* see the book for explanations and caveats! *********
      IMPLICIT DOUBLE PRECISION (A,R,Y)
      DIMENSION AA(*)
      PARAMETER (KK=100)
      PARAMETER (LL=37)
      COMMON /RSTATE/ RANX(KK)
      SAVE /RSTATE/
      DO 1 J=1,KK
 1    AA(J)=RANX(J)
      DO 2 J=KK+1,N
         Y=AA(J-KK)+AA(J-LL)
         AA(J)=Y-IDINT(Y)
 2    CONTINUE
      DO 3 J=1,LL
         Y=AA(N+J-KK)+AA(N+J-LL)
         RANX(J)=Y-IDINT(Y)
 3    CONTINUE
      DO 4 J=LL+1,KK
         Y=AA(N+J-KK)+RANX(J-LL)
         RANX(J)=Y-IDINT(Y)
 4    CONTINUE
      END
!
!
!
!
      SUBROUTINE RNFSTR(SEED)
      IMPLICIT DOUBLE PRECISION (A,R,U,V)
      IMPLICIT INTEGER (T)
      PARAMETER (KK=100)
      PARAMETER (LL=37)
      PARAMETER (MM=2**30)
      PARAMETER (ULP=1D0/(2D0**52))
      PARAMETER (TT=70)
      PARAMETER (KKK=KK+KK-1)
      INTEGER SEED,S,SSEED
      DOUBLE PRECISION SS
      DIMENSION U(KKK)
      COMMON /RSTATE/ RANX(KK)
      SAVE /RSTATE/
      IF (SEED .LT. 0) THEN
         SSEED=MM-1-MOD(-1-SEED,MM)
      ELSE
         SSEED=MOD(SEED,MM)
      END IF
      SS=2D0*ULP*(SSEED+2)
      DO 1 J=1,KK
         U(J)=SS
         SS=SS+SS
         IF (SS .GE. 1D0) SS=SS-1D0+2*ULP
 1    CONTINUE
      U(2)=U(2)+ULP
      S=SSEED
      T=TT-1
 10   DO 12 J=KK,2,-1
         U(J+J-1)=U(J)
 12      U(J+J-2)=0
      DO 14 J=KKK,KK+1,-1
         V=U(J-(KK-LL))+U(J)
         U(J-(KK-LL))=V-IDINT(V)
         V=U(J-KK)+U(J)
         U(J-KK)=V-IDINT(V)
 14   CONTINUE
      IF (MOD(S,2) .EQ. 1) THEN
         DO 16 J=KK,1,-1
 16         U(J+1)=U(J)
         U(1)=U(KK+1)
         V=U(LL+1)+U(KK+1)
         U(LL+1)=V-IDINT(V)
      END IF
      IF (S .NE. 0) THEN
         S=S/2
      ELSE
         T=T-1
      END IF
      IF (T .GT. 0) GO TO 10
      DO 20 J=1,LL
 20      RANX(J+KK-LL)=U(J)
      DO 21 J=LL+1,KK
 21      RANX(J-LL)=U(J)
      DO 22 J=1,10
 22      CALL RNFARR(U,KKK)
      END
!
!
!
!     ran1 is a linearly congruent 
!     random number generator from Numerical Recipies.
        double precision FUNCTION ran1(idum)
        implicit none
        INTEGER idum,IA,IM,IQ,IR,NTAB,NDIV
        integer counter
        REAL AM,EPS,RNMX
        PARAMETER (IA=16807,IM=2147483647,AM=1./IM,IQ=127773,IR=2836, &
     &          NTAB=32,NDIV=1+(IM-1)/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
!        PARAMETER (IA=16807,IM=2147483647,AM=1.d0/IM,IQ=127773,IR=2836,
!     @          NTAB=32,NDIV=1+(IM-1)/NTAB,EPS=AM,RNMX=1.d0-EPS)
        INTEGER j,k,iv(NTAB),iy
        SAVE iv,iy
        save counter
        DATA iv /NTAB*0/, iy /0/
        data counter /0/
!      write(4,*) 'iy=',iy
        counter = counter + 1
        if (idum.le.0.or.iy.eq.0) then
                idum=max(-idum,1)
                do j=NTAB+8,1,-1
                        k=idum/IQ
                        idum=IA*(idum-k*IQ)-IR*k
                        if (idum.lt.0) idum=idum+IM
                        if (j.le.NTAB) iv(j)=idum
                end do
                iy=iv(1)
        endif
        k=idum/IQ
        idum=IA*(idum-k*IQ)-IR*k
        if (idum.lt.0) idum=idum+IM
        j=1+iy/NDIV
        iy=iv(j)
        iv(j)=idum
        ran1=int(min(AM*iy,RNMX)*1.e7)/1.d7
!        write(4,*) 'ran1=', ran1
!        write(4,*) 'idum=',idum
!        write(4,*) 'iv1=', iv(1)
        return
        end
!

!
!ccccccccccccccccccccccccccccccccccccccccccccccccc 
! Sun Jun  4 19:34:23 EDT 2006
! version: 2
! Name: J. Finke
! Added rrand and zrand     
!
!ccccccccccccccccccccccccccccccccccccccccccccccccc 
! Fri Oct 20 18:06:32 EDT 2006
! version: 3
! Name: J. Finke
! Fixed bug where it reads buffer past randmax. 
